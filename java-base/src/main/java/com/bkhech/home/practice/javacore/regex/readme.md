# 正则表达式
## 1 定义：用于声明字符串的规则表达式。经常用于检测一个字符串是否符合特定规则。
## 2 语法：
### 预定义字符类 
    [abcd] abcd四个字符选一个
    [a-f] a到f字符选一个
    [^abcd] 除了abcd字符的其他字符
    
    缩写版本
    .  匹配除换行符以外的任意字符
    \d 匹配数字：[0-9] 
    \D 非数字： [^0-9] 
    \s 空白字符：[ \t\n\x0B\f\r]  
    \S 非空白字符：[^\s] 
    \w 匹配数字、字母、下划线：[a-zA-Z_0-9] 
    \W 非单词字符：[^\w] 
    
### 边界匹配器 
    ^ 行的开头 
    $ 行的结尾 
    \b 单词边界 
    \B 非单词边界 
    \A 输入的开头 
    \G 上一个匹配的结尾 
    \Z 输入的结尾，仅用于最后的结束符（如果有的话） 
    \z 输入的结尾 

### Greedy 数量词 
    X? X，一次或一次也没有 
    X* X，零次或多次 
    X+ X，一次或多次 
    X{n} X，恰好 n 次 
    X{n,} X，至少 n 次 
    X{n,m} X，至少 n 次，但是不超过 m 次         

### Logical 运算符 
    XY X 后跟 Y 
    X|Y X 或 Y 
    (X) X，作为捕获组 
### Back 引用 
    \n 任何匹配的捕获组
- 注：Back引用是说在后面的表达式中我们可以使用组的编号来引用前面的表达式所捕获到的文本序列(是文本不是正则)。     
    

### 分组 
#### 捕获组
    (序列1|序列2)    
eg:
```json
参考com.bkhech.home.practice.javacore.regex.PatternTest.test4()
```        
    
#### 非捕获组（特殊构造） 
    (?:X) X，作为非捕获组 
    (?idmsux-idmsux)  Nothing，但是将匹配标志i d m s u x on - off 
    (?idmsux-idmsux:X)   X，作为带有给定标志 i d m s u x on - off 
    的非捕获组  (?=X) X，通过零宽度的正 lookahead 
    (?!X) X，通过零宽度的负 lookahead 
    (?<=X) X，通过零宽度的正 lookbehind 
    (?<!X) X，通过零宽度的负 lookbehind 
    (?>X) X，作为独立的非捕获组 
    
    
     * 这四个非捕获组用于匹配表达式X，但是不包含表达式的文本。
     * (?=X )	零宽度正先行断言。仅当子表达式 X 在 此位置的右侧匹配时才继续匹配。例如，/w+(?=/d) 与后跟数字的单词匹配，而不与该数字匹配。此构造不会回溯。
     * (?!X)	零宽度负先行断言。仅当子表达式 X 不在 此位置的右侧匹配时才继续匹配。例如，例如，/w+(?!/d) 与后不跟数字的单词匹配，而不与该数字匹配。
     * (?<=X)	零宽度正后发断言。仅当子表达式 X 在 此位置的左侧匹配时才继续匹配。例如，(?<=19)99 与跟在 19 后面的 99 的实例匹配。此构造不会回溯。
     * (?<!X)	零宽度负后发断言。仅当子表达式 X 不在此位置的左侧匹配时才继续匹配。例如，(?<!19)99 与不跟在 19 后面的 99 的实例匹配
     *
     * 一般来说要如果是要对一个字符组合采用否定判定时一般都会用上先行断言和后发断言。
     * 例如左边不能包含1302和1301的字符串，因为你没法使用某种方式来否定一个1302四个字符的组合(注意：[^（1302)|(1301)]表示不能是1或者3或者0或者2，
     * 而不是1302一个整体)，只有先行或者后发断言可以表示一个整体 : 456(?<!1302|1301)789.
    
eg:
```json
以 (?) 开头的组是纯的非捕获组，它不捕获文本，也不针对组合进行计数。
就是说，如果小括号中以?号开头，那么这个分组就不会捕获文本，当然也不会有组的编号，因此也不存在Back引用。

正则表达式中有前瞻（Lookahead）和后顾（Lookbehind）的概念，这两个术语非常形象的描述了正则引擎的匹配行为。
需要注意一点，正则表达式中的前和后和我们一般理解的前后有点不同。一段文本，我们一般习惯把文本开头的方向称作“前面”，
文本末尾方向称为“后面”。但是对于正则表达式引擎来说，因为它是从文本头部向尾部开始解析的（可以通过正则选项控制解析方向），
因此对于文本尾部方向，称为“前”，因为这个时候，正则引擎还没走到那块，而对文本头部方向，则称为“后”，因为正则引擎已经走过了
那一块地方。如下图所示：
![avatar](./image/正向前瞻逆向前瞻.png)

所谓的前瞻就是在正则表达式匹配到某个字符的时候，往“尚未解析过的文本”预先看一下，看是不是符合/不符合匹配模式，
而后顾，就是在正则引擎已经匹配过的文本看看是不是符合/不符合匹配模式。符合和不符合特定匹配模式我们又称为肯定式匹配和否定式匹配。

现代高级正则表达式引擎一般都支持都支持前瞻，对于后顾支持并不是很广泛，因此我们这里采用否定式前瞻来实现我们的需求。

参考com.bkhech.home.practice.javacore.regex.PatternTest.test5()、test6()、test7()

https://blog.csdn.net/lovingprince/article/details/2774819
http://www.imkevinyang.com/2009/08/%E4%BD%BF%E7%94%A8%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%89%BE%E5%87%BA%E4%B8%8D%E5%8C%85%E5%90%AB%E7%89%B9%E5%AE%9A%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%9D%A1%E7%9B%AE.html

```
    
    
    
    
### 常见案例:

```java
邮政编码的规则 \d{6}
身份证的规则 d{17}[\dXx]
用户名的规则: 8到11个单词字符 \w{8,11}
检查一个文件是否为jpeg照片文件： .+\.jpe?g
检查一个文件是否为照片文件： .+\.(jpe?g|png|gif)
Excel能够支持的文件名规则 ： .+\.xls[xbm]?
手机号的规则： (0086|\+86)?\s*1\d{10}
```    

